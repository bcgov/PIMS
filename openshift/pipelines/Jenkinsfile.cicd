#!groovy

// ------------------
// Pipeline Variables
// ------------------
def commonPipeline
def notify

def FE_COV_STASH = 'fe-test-coverage'
def API_COV_STASH = 'api-test-coverage'
def RELEASE_VERSION = ""

// --------------------
// Declarative Pipeline
// --------------------
pipeline {
  agent any
  options {
    disableResume()
    buildDiscarder(logRotator(numToKeepStr: "5")) // keep 5 builds only
  }
  environment {
    CI = "true"

    // To enable pipeline verbose debug output set to "true"
    DEBUG_OUTPUT = "false"

    // To force asking for a release version before running the pipeline, set to "true"
    REQUIRE_VERSION = "false"

    // The name of your application
    APP_NAME = "pims"

    // The name of the project namespace(s).
    NAME_SPACE = "jcxjin"

    // This should match your monorepo folder structure
    API_DIRECTORY = "backend"
    FRONTEND_DIRECTORY = "frontend"
    MAINTENANCE_DIRECTORY = "maintenance"
    DEVOPS_DIRECTORY = "openshift"

    // Environment Variables that should be set in OpenShift
    // -----------------------------------------------------
    // The job identifier (i.e 'pr-5' OR 'dev' OR 'master')
    // JOB_NAME = "dev"

    // Which environment to deploy to ('dev' OR 'test' OR 'prod').
    // DESTINATION = "dev"

    // The URI to the application being deployed.
    // VANITY_URL="https://pims-dev.pathfinder.gov.bc.ca/"
  }
  stages {
    stage("Initialize") {
      steps {
        script {
          // load supporting functions from external script files
          commonPipeline = load "openshift/pipelines/scripts/common.groovy"
          notify = load "openshift/pipelines/scripts/notify.groovy"

          // Cancel any running builds in progress
          timeout(time: 10, unit: 'MINUTES') {
            echo "Cancelling previous builds in progress..."
            commonPipeline.abortAllPreviousBuildsInProgress(currentBuild)
          }

          // ensure required secrets and credentials are available in the CI environment
          // [add more secrets here if needed...]
          sh "oc extract secret/rocket-chat-secrets --to=${env.WORKSPACE} --confirm"
          env.ROCKET_DEPLOY_WEBHOOK = readFile("rocket-deploy-webhook").trim()

          // initialize CI environment values
          env.CHANGELOG = commonPipeline.getChangeLog()

          // whether Build and Deploy stage should be skipped
          def api_changes = commonPipeline.hasDirectoryChanged('backend').toString()
          def fe_changes = commonPipeline.hasDirectoryChanged('frontend').toString()

          if (api_changes.equalsIgnoreCase("false") && fe_changes.equalsIgnoreCase("false")) {
            env.SKIP_BUILD = "true"
          } else {
            env.SKIP_BUILD = "false"
          }

          if (DEBUG_OUTPUT.equalsIgnoreCase("true")) {
            // Force OpenShift Plugin directives to be verbose
            openshift.logLevel(1)

            // Print all environment variables
            echo 'DEBUG - All pipeline environment variables:'
            echo sh(returnStdout: true, script: 'env')
          }
        }
      }
    }

    stage("Version Prompt") {
      when {
        anyOf {
          expression { env.GIT_BRANCH == "origin/master" }
          expression { env.REQUIRE_VERSION == "true" }
        }
      }
      steps {
        script {
          timeout(time: 5, unit: "MINUTES") {
            def version = input(message: "Enter the version tag for this release", parameters: [
              string(name: "RELEASE VERSION", defaultValue: "", description: "")
            ])
            if (version != "") {
              RELEASE_VERSION = version
            } else {
              error "***  No release version specified. Aborting pipeline.  ***"
            }
          }
        }
      }
    }

    stage("Force Build?") {
      when {
        expression { env.SKIP_BUILD == "true" }
      }
      steps {
        script {
          try {
            timeout(time: 2, unit: "MINUTES") {
              input(message: "No code changes detected. Should we force the Build?", ok: "Yes, we should")
            }
            env.SKIP_BUILD = "false"
          } catch (err) {
            echo "[ci/cd]  No code changes. Skipping the Build stage..."
            env.SKIP_BUILD = "true"
          }
        }
      }
    }

    stage('Tests') {
      when {
        expression { env.SKIP_BUILD == "false" }
      }
      options { timeout(time: 10, unit: "MINUTES") }
      failFast true
      parallel {
        stage("Frontend") {
          agent { label 'jenkins-slave-npm' }
          steps {
            script {
              commonPipeline.runFrontendTests()
            }
          }
          post {
            success {
              echo 'Frontend lint checks and tests passed'
              stash name: FE_COV_STASH, includes: 'frontend/coverage/**'
            }
            failure {
              error '*** Frontend lint checks and tests failed ***'
            }
          }
        }
        stage("Backend") {
          agent { label 'jenkins-slave-dotnet' }
          steps {
            script {
              commonPipeline.runBackendTests()
            }
          }
          post {
            success {
              echo 'Backend tests passed'
              stash name: API_COV_STASH, includes: 'backend/tests/unit/TestResults/**'
            }
            failure {
              error '*** Backend tests failed ***'
            }
          }
        }
      }
    }

    stage('Build') {
      when {
        expression { env.SKIP_BUILD == "false" }
      }
      options { timeout(time: 25, unit: "MINUTES") }
      failFast true
      parallel {
        stage("Frontend") {
          steps {
            script {
              dir(DEVOPS_DIRECTORY) {
                sh "JOB_NAME=${JOB_NAME} ./player.sh build app-base apply"
                sh "JOB_NAME=${JOB_NAME} ./player.sh build app apply"
              }
            }
          }
        }
        stage("Backend") {
          steps {
            dir(DEVOPS_DIRECTORY) {
              sh "JOB_NAME=${JOB_NAME} ./player.sh build api apply"
            }
          }
        }
      }
    }

    stage("Quality Gate") {
      when {
        expression { env.SKIP_BUILD == "false" }
      }
      options {
        timeout(time: 1, unit: "MINUTES")
      }
      steps {
        echo 'TODO: SonarQube integration'

        // unstash API_COV_STASH
        // unstash FE_COV_STASH

        // echo 'Performing SonarQube static code analysis...'
        // sh """
        // sonar-scanner \
        //   -Dsonar.host.url='${SONARQUBE_URL_INT}' \
        //   -Dsonar.projectKey='${REPO_NAME}-${JOB_NAME}' \
        //   -Dsonar.projectName='NRPTI (${JOB_NAME.toUpperCase()})'
        // """
      }
    }

    stage("Deploy") {
      when {
        expression { env.SKIP_BUILD == "false" }
      }
      options { timeout(time: 15, unit: "MINUTES") }
      steps {
        script {
          def img_backend = "${APP_NAME}-api"
          def img_frontend = "${APP_NAME}-app"

          // tag release version (if provided)
          if (RELEASE_VERSION != "") {
            echo "Tagging images - ${img_backend}:latest, ${img_frontend}:latest..."
            sh "oc tag ${img_backend}:latest ${img_backend}:${RELEASE_VERSION}"
            sh "oc tag ${img_frontend}:latest ${img_frontend}:${RELEASE_VERSION}"
          } else {
            RELEASE_VERSION = "latest"
          }

          dir(DEVOPS_DIRECTORY) {
            sh "RELEASE_TAG=${RELEASE_VERSION} ./player.sh deploy api ${DESTINATION} apply"
            sh "RELEASE_TAG=${RELEASE_VERSION} ./player.sh deploy app ${DESTINATION} apply"
          }
        }
      }
    }

  } // stages
  post {
    success {
      script {
        if (env.SKIP_BUILD == "false") {
          notify.success(APP_NAME.toUpperCase(), RELEASE_VERSION, DESTINATION.toUpperCase(), ROCKET_DEPLOY_WEBHOOK)
        }
      }
    }
    failure {
      script {
        notify.failure(APP_NAME.toUpperCase(), RELEASE_VERSION, DESTINATION.toUpperCase(), ROCKET_DEPLOY_WEBHOOK)
      }
    }
  } // post-stages
} // pipeline
