#!groovy

// ------------------
// Pipeline Variables
// ------------------
def cli
def notify

def FE_COV_STASH = 'fe-test-coverage'
def API_COV_STASH = 'api-test-coverage'

// --------------------
// Declarative Pipeline
// --------------------
pipeline {
  agent any
  options {
    disableResume()
    buildDiscarder(logRotator(numToKeepStr: "5")) // keep 5 builds only
  }
  environment {
    // To enable pipeline verbose debug output set to "true"
    DEBUG_OUTPUT = "false"

    // Wait timeout in minutes
    WAIT_TIMEOUT = 15

    CI = "true"

    // The name of your application
    APP_NAME = "pims"

    // This should match your monorepo folder structure
    API_CONTEXT_DIRECTORY = "backend"
    FRONTEND_CONTEXT_DIRECTORY = "frontend"

    // The name of the project namespace(s).
    NAME_SPACE = "jcxjin"

    // Environment Variables that should be set in OpenShift
    // -----------------------------------------------------
    // The tag used to identify the image.
    // IMAGE_TAG = "dev"

    // Which environment to deploy to.
    // DESTINATION = "dev"

    // The URI to the application being deployed.
    // VANITY_URL="https://pims-dev.pathfinder.gov.bc.ca/"
  }
  stages {
    stage("Initialize") {
      steps {
        script {
          // load supporting functions from external script files
          cli = load "openshift/pipelines/scripts/common.groovy"
          notify = load "openshift/pipelines/scripts/notify.groovy"

          // ensure required secrets and credentials are available in the CI environment
          // [add more secrets here if needed...]
          sh "oc extract secret/rocket-chat-secrets --to=${env.WORKSPACE} --confirm"

          // initialize CI environment values
          env.ROCKET_DEPLOY_WEBHOOK = readFile("rocket-deploy-webhook").trim()
          env.CHANGELOG = cli.getChangeLog()

          // back-end CI flags
          def api_changes = cli.hasDirectoryChanged(API_CONTEXT_DIRECTORY)
          env.API_HAS_CHANGES = api_changes.toString()
          env.API_FORCE_BUILD = "false"
          env.API_BUILT = "false"
          env.API_DEPLOYED = "false"

          // front-end CI flags
          def fe_changes = cli.hasDirectoryChanged(FRONTEND_CONTEXT_DIRECTORY)
          env.FRONTEND_HAS_CHANGES = fe_changes.toString()
          env.FRONTEND_FORCE_BUILD = "false"
          env.FRONTEND_BUILT = "false"
          env.FRONTEND_DEPLOYED = "false"

          if (DEBUG_OUTPUT.equalsIgnoreCase("true")) {
            // Force OpenShift Plugin directives to be verbose
            openshift.logLevel(1)

            // Print all environment variables
            echo 'DEBUG - All pipeline environment variables:'
            echo sh(returnStdout: true, script: 'env')
          }
        }
      }
    }
    stage("Force API Build?") {
      when { environment name: "API_HAS_CHANGES", value: "false" }
      steps {
        script {
          try {
            timeout(time: 1, unit: "MINUTES") {
              input(message: "Should we force the API Build?", ok: "Yes, we should")
            }
            echo "[ci/cd]  The API build was forced..."
            env.API_FORCE_BUILD = "true"
          } catch (err) {
            echo "[ci/cd]  No API code changes. Skipping the API build..."
            env.API_FORCE_BUILD = "false"
          }
        }
      }
    }
    stage("Build API and run tests") {
      environment {
        COMP_NAME = "api"
      }
      when {
        anyOf {
          environment name: "API_HAS_CHANGES", value: "true"
          environment name: "API_FORCE_BUILD", value: "true"
        }
      }
      steps {
        echo "[ci/cd]  Building API artifacts..."
        script {
          openshift.withCluster() {
            openshift.withProject() {
              def build_config = "${APP_NAME}-${COMP_NAME}-${IMAGE_TAG}"
              def apiSelector = openshift.selector("bc", build_config)
              if (!apiSelector.exists()) {
                throw new Exception("Could not find API build with name: '${build_config}'")
              } else {
                timeout(WAIT_TIMEOUT) {
                  apiSelector.startBuild("-w")
                }
              }
            }
          }
        }
      }
      post {
        success {
          script {
            env.API_BUILT = "true"
          }
        }
      }
    }
    stage("Force FRONTEND Build?") {
      when { environment name: "FRONTEND_HAS_CHANGES", value: "false" }
      steps {
        script {
          try {
            timeout(time: 1, unit: "MINUTES") {
              input(message: "Should we force the FRONTEND Build?", ok: "Yes, we should")
            }
            echo "[ci/cd]  The FRONTEND build was forced..."
            env.FRONTEND_FORCE_BUILD = "true"
          } catch (err) {
            echo "[ci/cd]  No FRONTEND code changes. Skipping the FRONTEND build..."
            env.FRONTEND_FORCE_BUILD = "false"
          }
        }
      }
    }
    stage("Build FRONTEND") {
      environment {
        COMP_NAME = "app"
        WAIT_TIMEOUT = 20 // increase the timeout for this stage as it takes longer to build
      }
      when {
        anyOf {
          environment name: "FRONTEND_HAS_CHANGES", value: "true"
          environment name: "FRONTEND_FORCE_BUILD", value: "true"
        }
      }
      steps {
        echo "[ci/cd]  Building FRONTEND artifacts..."
        script {
          openshift.withCluster() {
            openshift.withProject() {
              // Build the base image. This image leverages Node to create a production build of the React frontend.
              def build_config = "${APP_NAME}-${COMP_NAME}-base-${IMAGE_TAG}"
              def feBase = openshift.selector("bc", build_config)
              if (!feBase.exists()) {
                throw new Exception("Could not find FRONTEND-base build with name: '${build_config}'")
              } else {
                timeout(WAIT_TIMEOUT) {
                  feBase.startBuild("-w")
                }
              }

              // Build the runtime image. This image serves the compiled React artifacts via an NGINX web-server.
              def runtime_build_config = "${APP_NAME}-${COMP_NAME}-${IMAGE_TAG}"
              def feRuntime = openshift.selector("bc", runtime_build_config)
              if (!feRuntime.exists()) {
                throw new Exception("Could not find FRONTEND-runtime build with name: '${runtime_build_config}'")
              } else {
                timeout(WAIT_TIMEOUT) {
                  feRuntime.startBuild("-w")
                }
              }
            }
          }
        }
      }
      post {
        success {
          script {
            env.FRONTEND_BUILT = "true"
          }
        }
      }
    }
    stage("FRONTEND Tests") {
      agent {
        label 'jenkins-slave-npm'
      }
      environment {
        COMP_NAME = "app"
        CI = "true"
      }
      when {
        anyOf {
          environment name: "FRONTEND_BUILT", value: "true"
        }
      }
      steps {
        echo "[ci/cd]  Run FRONTEND Test Cases"
        script {
          // pull code
          checkout scm

          dir(FRONTEND_CONTEXT_DIRECTORY) {
            try {
              timeout(20) {
                sh 'node --version'
                sh 'npm --version'

                echo 'Installing NPM Dependencies...'
                sh 'npm ci'

                echo 'Reporting Outdated and Vulnerable Dependencies...'
                sh 'npm audit || true'
                sh 'npm outdated || true'

                echo "Linting and Testing Frontend..."
                sh 'npm run lint'
                sh 'npm run coverage'

                echo 'Frontend Lint Checks and Tests passed'
              }
            } catch (e) {
              echo 'Lint Checks and Tests failed'
              throw e
            }
          }
        }
      }
      post {
        success {
          stash name: FE_COV_STASH, includes: 'frontend/coverage/**'
          echo 'All Tests passed'
        }
        failure {
          echo 'Tests failed'
        }
      }
    }
    stage("API Tests") {
      agent {
        label 'jenkins-slave-dotnet'
      }
      environment {
        COMP_NAME = "api"
        CI = "true"
      }
      when {
        anyOf {
          environment name: "API_BUILT", value: "true"
        }
      }
      steps {
        echo "[ci/cd]  Run API Test Cases"
        script {
          // pull code
          checkout scm

          dir(API_CONTEXT_DIRECTORY) {
            try {
              timeout(20) {
                sh 'dotnet --version'
                sh 'node --version'

                echo 'Install dependencies...'
                sh 'dotnet restore'

                echo 'Build'
                sh 'dotnet build --configuration Release --no-restore'

                echo 'Testing the API...'
                sh 'dotnet test --no-restore'

                echo 'Generate code coverage'
                sh '''
                coverlet ./tests/unit/api/bin/Release/netcoreapp3.1/Pims.Api.Test.dll \
                  --target "dotnet" \
                  --targetargs "test ./ --no-build" \
                  -o "./tests/TestResults/api-coverage.json" \
                  --exclude "[*.Test]*" \
                  --exclude "[*]*Model" \
                  --exclude-by-attribute "CompilerGenerated" \
                  -f json
                '''
                sh '''
                coverlet ./tests/unit/dal/bin/Release/netcoreapp3.1/Pims.Dal.Test.dll \
                  --target "dotnet" \
                  --targetargs "test ./ --no-build" \
                  -o "./tests/TestResults/coverage.xml" \
                  --exclude "[*.Test]*" \
                  --exclude "[*]*Model" \
                  --exclude-by-attribute "CompilerGenerated" \
                  --merge-with "./tests/TestResults/api-coverage.json" \
                  -f opencover
                '''

                echo 'API Tests passed'
              }
            } catch (e) {
              echo 'Lint Checks and Tests failed'
              throw e
            }
          }
        }
      }
      post {
        success {
          stash name: API_COV_STASH, includes: 'backend/tests/TestResults/**'
          echo 'All Tests passed'
        }
        failure {
          echo 'Tests failed'
        }
      }
    }
    stage("Quality Gate") {
      options {
        timeout(time: 1, unit: "MINUTES")
      }
      steps {
        echo 'TODO: SonarQube integration'

        // unstash API_COV_STASH
        // unstash FE_COV_STASH

        // echo 'Performing SonarQube static code analysis...'
        // sh """
        // sonar-scanner \
        //   -Dsonar.host.url='${SONARQUBE_URL_INT}' \
        //   -Dsonar.projectKey='${REPO_NAME}-${JOB_NAME}' \
        //   -Dsonar.projectName='NRPTI (${JOB_NAME.toUpperCase()})'
        // """
      }
    }
    stage("Tag API") {
      environment {
        COMP_NAME = "api"
      }
      steps {
        script {
          openshift.withCluster() {
            openshift.withProject() {
              try {
                timeout(time: 1, unit: "MINUTES") {
                  def api_tag = input(message: "Enter the desired API tag", parameters: [
                    string(name: 'API_TAG', defaultValue: '', description: 'Tag to apply to the API image.')
                  ])
                  if (api_tag != '') {
                    def image_name = "${APP_NAME}-${COMP_NAME}"
                    def hash = cli.getImageTagHash("${image_name}")
                    echo "[ci/cd]  Create permanent tag ${api_tag} for image ${image_name}@${hash}"
                    openshift.tag("${image_name}@${hash}", "${image_name}:${api_tag}")
                  }
                }
              } catch (err) {
                echo "${err}"
                echo "[ci/cd]  No api tag specified"
              }
            }
          }
        }
      }
    }
    stage("Tag App") {
      environment {
        COMP_NAME = "app"
      }
      steps {
        script {
          openshift.withCluster() {
            openshift.withProject() {
              try {
                timeout(time: 1, unit: "MINUTES") {
                  def app_tag = input(message: "Enter the desired App tag", parameters: [
                    string(name: 'APP_TAG', defaultValue: '', description: 'Tag to apply to the App image.')
                  ])
                  if (app_tag != '') {
                    def image_name = "${APP_NAME}-${COMP_NAME}"
                    def hash = cli.getImageTagHash("${image_name}")
                    echo "[ci/cd]  Create permanent tag ${app_tag} for image ${image_name}@${hash}"
                    openshift.tag("${image_name}@${hash}", "${image_name}:${app_tag}")
                  }
                }
              } catch (err) {
                echo "${err}"
                echo "[ci/cd]  No app tag specified"
              }
            }
          }
        }
      }
    }
    stage("Deploy API -> DEV") {
      options {
        timeout(time: 5, unit: "MINUTES")
      }
      environment {
        COMP_NAME = "api"
      }
      when { environment name: "API_BUILT", value: "true" }
      steps {
        script {
          openshift.withCluster() {
            openshift.withProject() {
              def image_name = "${APP_NAME}-${COMP_NAME}"
              // Don't tag with BUILD_ID so the pruner can do it's job; it won't delete tagged images.
              // Tag the images for deployment based on the image's hash
              def hash = cli.getImageTagHash("${image_name}")
              echo "[ci/cd]  Tagging ${image_name}@${hash} for deployment to ${DESTINATION.toUpperCase()} ..."
              openshift.tag("${image_name}@${hash}", "${image_name}:${DESTINATION}")
            }

            openshift.withProject("${NAME_SPACE}-${DESTINATION}") {
                def dc = openshift.selector("dc", [ app: APP_NAME, component: COMP_NAME ])
                echo "[ci/cd]  Found ${dc.count()} DeploymentConfigs: ${dc.names()}"
                // Wait for the deployment to complete.
                // This will wait until the desired replicas are all available
                dc.rollout().status()
            }
          }
        }
        echo "[ci/cd]  API deployment done..."
      }
      post {
        success {
          script {
            env.API_DEPLOYED = "true"
          }
        }
      }
    }
    stage("Deploy frontend -> DEV") {
      options {
        timeout(time: 5, unit: "MINUTES")
      }
      environment {
        COMP_NAME = "app"
      }
      when { environment name: "FRONTEND_BUILT", value: "true" }
      steps {
        script {
          openshift.withCluster() {
            openshift.withProject() {
              def image_name = "${APP_NAME}-${COMP_NAME}"
              // Don't tag with BUILD_ID so the pruner can do it's job; it won't delete tagged images.
              // Tag the images for deployment based on the image's hash
              def hash = cli.getImageTagHash("${image_name}")
              echo "[ci/cd]  Tagging ${image_name}@${hash} for deployment to ${DESTINATION.toUpperCase()} ..."
              openshift.tag("${image_name}@${hash}", "${image_name}:${DESTINATION}")
            }

            openshift.withProject("${NAME_SPACE}-${DESTINATION}") {
                def dc = openshift.selector("dc", [ app: APP_NAME, component: COMP_NAME ])
                echo "[ci/cd]  Found ${dc.count()} DeploymentConfigs: ${dc.names()}"
                // Wait for the deployment to complete.
                // This will wait until the desired replicas are all available
                dc.rollout().status()
            }
          }
        }
        echo "[ci/cd]  Frontend deployment done..."
      }
      post {
        success {
          script {
            env.FRONTEND_DEPLOYED = "true"
          }
        }
      }
    }
    stage("Notify") {
      when {
        anyOf {
          environment name: "API_DEPLOYED", value: "true"
          environment name: "FRONTEND_DEPLOYED", value: "true"
        }
      }
      steps {
        script {
          if (env.API_DEPLOYED.equalsIgnoreCase("true")) {
            notify.deploySuccess("${APP_NAME.toUpperCase()} API", DESTINATION.toUpperCase(), CHANGELOG, VANITY_URL, ROCKET_DEPLOY_WEBHOOK)
          }
          if (env.FRONTEND_DEPLOYED.equalsIgnoreCase("true")) {
            notify.deploySuccess("${APP_NAME.toUpperCase()} FRONTEND", DESTINATION.toUpperCase(), CHANGELOG, VANITY_URL, ROCKET_DEPLOY_WEBHOOK)
          }
        }
      }
    }
    stage("No Changes") {
      when {
        allOf {
          environment name: "API_DEPLOYED", value: "false"
          environment name: "FRONTEND_DEPLOYED", value: "false"
        }
      }
      steps {
        script {
          echo "[ci/cd]  No changes ..."
          currentBuild.result = 'ABORTED'
          notify.noChanges(APP_NAME.toUpperCase(), DESTINATION.toUpperCase(), ROCKET_DEPLOY_WEBHOOK)
        }
      }
    }
  } // stages
  post {
    aborted {
      node('master') {
        script {
          notify.deployFailure(APP_NAME.toUpperCase(), DESTINATION.toUpperCase(), "PIPELINE ABORTED", VANITY_URL, ROCKET_DEPLOY_WEBHOOK)
        }
    }
    }
    failure {
      node('master') {
        script {
          notify.deployFailure(APP_NAME.toUpperCase(), DESTINATION.toUpperCase(), "PIPELINE ERROR", VANITY_URL, ROCKET_DEPLOY_WEBHOOK)
        }
      }
    }
  } // post
} // pipeline
